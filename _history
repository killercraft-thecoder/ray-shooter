{"entries":[{"timestamp":1743009380847,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1273,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1225,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":181,"length1":72,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":210,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"tilemap.g.jres","value":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}"},{"type":"added","filename":"tilemap.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tilemap\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"level1\":\n            case \"level1\":return tiles.createTilemap(hex`1000100000000000000000000000000000000000010101010101010101000000000000000000000000000000000101000000000000000000000000000000010100000000000000000000000000000001010100000000000000000000000000000000010100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001010000000000000000000000000000010101000000000000000000000000000100010101010101010000000000000100000000000000000001010100000001000000000000000000000000010101000000000000000000000000000000000000`, img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`, [myTiles.transparency16,sprites.castle.tileGrass2], TileScale.Sixteen);\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1743009842540,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":709,"length1":27,"diffs":[[1,"        const oy = this.y\n"]]}]}]},{"timestamp":1743011045461,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":683,"length1":27,"diffs":[[1,"        const ox = this.x\n"]]}]}]},{"timestamp":1743011047028,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":107,"length1":93,"diffs":[[1,"    constructor(x:number,y:number,vx:number,vy:number) {\n"]]},{"start1":236,"length1":25,"diffs":[[1,""]]},{"start1":345,"length1":260,"diffs":[[1,"         const col = Math.round(this.y / 16)\n         const row = Math.round(this.x / 16)\n         if (tiles.tileAtLocationEquals(tiles.getTileLocation(col, row), sprites.castle.tileGrass2)) {\n          scene.backgroundImage().setPixel(this.x,this.y,1)\n"]]},{"start1":791,"length1":65,"diffs":[[1,""]]},{"start1":864,"length1":43,"diffs":[[1,""]]},{"start1":939,"length1":34,"diffs":[[1,"        game.onUpdate(function() {\n"]]},{"start1":999,"length1":108,"diffs":[[1,""]]},{"start1":1030,"length1":152,"diffs":[[1,"        for (let i = 0; i < 100; i++) {\n            for (let k = 0; k < 100; k++) {\n                const ray = new Ray(this.x,this.y,i,k)\n"]]},{"start1":1193,"length1":62,"diffs":[[1,""]]},{"start1":1201,"length1":81,"diffs":[[1,""]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":1060,"diffs":[[1,"        \"data\": \"MTAxMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n"]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":922,"length1":462,"diffs":[[1,""]]},{"start1":955,"length1":0,"diffs":[[1,". . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n"]]}]}]},{"timestamp":1743011645315,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":112,"diffs":[[1,""]]},{"start1":41,"length1":31,"diffs":[[1,""]]},{"start1":362,"length1":192,"diffs":[[1,""]]},{"start1":571,"length1":122,"diffs":[[1,"          this.light.lightMap \n          scene.backgroundImage().fillCircle(this.x,this.y,3,2)\n"]]},{"start1":718,"length1":44,"diffs":[[1,"              break;\n"]]},{"start1":859,"length1":112,"diffs":[[1,"         scene.backgroundImage().drawLine(ox,oy,this.x,this.y,1)\n"]]},{"start1":997,"length1":118,"diffs":[[1,"    lightMap: {hx:number,hy:number}[] = []\n    constructor(x:number,y:number) {\n"]]},{"start1":1149,"length1":43,"diffs":[[1,""]]},{"start1":1174,"length1":76,"diffs":[[1,"            this.x += Math.sin(game.runtime() / 1000)\n            this.y += Math.sin(game.runtime() / 1000)\n"]]},{"start1":1313,"length1":92,"diffs":[[1,"        for (let i = -32; i < 32; i += 6) {\n            for (let k = -32; k < 32; k += 6) {\n"]]},{"start1":1585,"length1":52,"diffs":[[1,"    scene.setBackgroundImage(image.create(160,120))\n"]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":1060,"diffs":[[1,"        \"data\": \"MTAxMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMDIwMDAwMDAwMDAwMDAwMDIwMDIwMDAwMDAwMDAwMDAwMDIyMDAwMDAwMDAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMDAwMDIyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAyMjAwMDAwMDAwMDAwMDIwMjAyMjIyMjIwMDAwMDAwMjAwMDAwMDAwMjIwMjAwMDIwMDAwMDAwMDAwMjAyMjAwMDAwMDAwMDAwMDAwMDAwMA==\",\n"]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":304,"length1":750,"diffs":[[1,"            case \"level1\":return tiles.createTilemap(hex`1000100000000000000000000000000000000000010101010101010101000000000000000000000000000000000101000000000000000000000000000000010100000000000000000000000000000001010100000000000000000000000000000000010100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001010000000000000000000000000000010101000000000000000000000000000100010101010101010000000000000100000000000000000001010100000001000000000000000000000000010101000000000000000000000000000000000000`, img`\n. . . . . . . . . . . . . . . . \n2 2 2 2 2 2 2 2 2 . . . . . . . \n. . . . . . . . . 2 2 . . . . . \n. . . . . . . . . . 2 2 . . . . \n. . . . . . . . . . . 2 2 2 . . \n"]]},{"start1":1285,"length1":132,"diffs":[[1,". 2 2 2 2 2 2 2 . . . . . . 2 . \n. . . . . . . . 2 2 2 . . . 2 . \n. . . . . . . . . . . 2 2 2 . . \n. . . . . . . . . . . . . . . . \n"]]}]}]},{"timestamp":1743012231934,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":230,"length1":53,"diffs":[[1,"        \"tilemap.g.ts\"\n"]]}]},{"type":"added","filename":"raytracer_class.ts","value":""}]},{"timestamp":1743013174107,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":0,"length1":828,"diffs":[[1,""]]}]}]},{"timestamp":1743013174302,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":415,"length1":26,"diffs":[[1,"      this.light = light\n"]]},{"start1":1585,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":45,"diffs":[[1,"    \"name\": \"ray shooter\",\n"]]},{"start1":254,"length1":53,"diffs":[[1,"        \"raytracer_class.ts\"\n"]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":0,"length1":177,"diffs":[[1,"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://arcade.makecode.com/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"ïƒƒ\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n"]]},{"start1":584,"length1":316,"diffs":[[1,"\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n"]]},{"start1":826,"length1":67,"diffs":[[1,"}\n"]]}]},{"type":"added","filename":"raytracer.ts","value":"const rt = new RayTracer()\r\n"}]},{"timestamp":1743013708316,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":571,"length1":77,"diffs":[[1,""]]}]}]},{"timestamp":1743014310932,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":230,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1743014313970,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1931,"length1":84,"diffs":[[1,"                const ray = new Ray(this.x,this.y,i,k,this)\n"]]},{"start1":2085,"length1":408,"diffs":[[1,""]]},{"start1":2166,"length1":160,"diffs":[[1,"const l = new Light(80,80)"]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":230,"length1":438,"diffs":[[1,"        \n        for (let i = 0; i < this.lights.length - 1; i++) {\n            const intersections_ = this.lights[i].lightMap // get the intersections\n            intersections_.forEach((a,b) => this.intersections.push(a)) // and push them onto this RayTracer's list\n"]]},{"start1":574,"length1":89,"diffs":[[1,""]]}]}]},{"timestamp":1743014913551,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":69,"diffs":[[1,"namespace userconfig {\n"]]},{"start1":153,"length1":30,"diffs":[[1,"const DRAW_DEBUG_LINES = false\n"]]},{"start1":1245,"length1":37,"diffs":[[1,""]]},{"start1":1388,"length1":251,"diffs":[[1,""]]},{"start1":2291,"length1":72,"diffs":[[1,""]]},{"start1":2297,"length1":83,"diffs":[[1,""]]},{"start1":2400,"length1":468,"diffs":[[1,""]]},{"start1":2424,"length1":322,"diffs":[[1,"            // stop the rau\n            ray.vx = 0\n            ray.vy = 0\n"]]},{"start1":2598,"length1":60,"diffs":[[1,""]]},{"start1":2628,"length1":68,"diffs":[[1,"    const l = new Light(Math.random() * 30, Math.random() * 30)\n    const l_ = new Light(Math.random() * 30, Math.random() * 30)\n"]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":2340,"diffs":[[1,"        \"data\": \"MTAxMDAwMTAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMjIyMjIyMjIyMjAyMDAwMDIyMjIyMjIyMjIyMjAyMDAwMDAwMDAwMDIwMjIwMjAwMDAwMDAwMDAwMDIyMjIwMjAwMDAwMDAwMDAyMDIyMjIwMDAwMDAwMDAwMDAwMDIyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAyMjAwMDAwMDAwMDAwMDIwMjIyMjIyMjIwMDAwMDAyMjIyMjIyMjIyMjIwMjAwMjIwMDAwMDAyMDIyMjIyMjIyMDAwMDAwMDAwMDIyMjIwMg==\",\n"]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":304,"length1":1825,"diffs":[[1,"            case \"level1\":return tiles.createTilemap(hex`1000100001010101010101010101010000000000010101010101010101010101010000000000000000000000000101010100000000000000000000000000010101010100000000000000000000000001010101010000000000000000000000000000010100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001010000000000000000000000000000010101000000000000000000000000000101010101010101010000000000000101010101010101010101010100000001010000000000000001010101010101010100000000000000000000010101010100`, img`\n2 2 2 2 2 2 2 2 2 2 2 . . . . . \n2 2 2 2 2 2 2 2 2 2 2 2 2 . . . \n. . . . . . . . . 2 2 2 2 . . . \n. . . . . . . . . . 2 2 2 2 2 . \n. . . . . . . . . . . 2 2 2 2 2 \n. . . . . . . . . . . . . . 2 2 \n. . . . . . . . . . . . . . . 2 \n. . . . . . . . . . . . . . . 2 \n. . . . . . . . . . . . . . . 2 \n. . . . . . . . . . . . . . . 2 \n2 . . . . . . . . . . . . . . 2 \n2 2 . . . . . . . . . . . . . 2 \n2 2 2 2 2 2 2 2 . . . . . . 2 2 \n2 2 2 2 2 2 2 2 2 2 2 . . . 2 2 \n. . . . . . . 2 2 2 2 2 2 2 2 2 \n. . . . . . . . . . 2 2 2 2 2 . \n"]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":42,"length1":26,"diffs":[[1,""]]},{"start1":839,"length1":71,"diffs":[[1,""]]}]}]},{"timestamp":1743015516061,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2582,"length1":44,"diffs":[[1,"        this.reflectIndex = Math.random()\n"]]}]}]},{"timestamp":1743015547998,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":295,"length1":16,"diffs":[[1,""]]},{"start1":486,"length1":20,"diffs":[[1,""]]},{"start1":551,"length1":88,"diffs":[[1,"        const col = Math.round(this.x / 16)\n        const row = Math.round(this.y / 16)\n"]]},{"start1":952,"length1":71,"diffs":[[1,"          this.light.lightMap.push({hx:this.x,hy:this.y})\n"]]},{"start1":1103,"length1":55,"diffs":[[1,"          if (it>30) {\n"]]},{"start1":1290,"length1":62,"diffs":[[1,""]]},{"start1":1715,"length1":455,"diffs":[[1,""]]},{"start1":1763,"length1":90,"diffs":[[1,"    lightMap: {hx:number,hy:number}[] = [] // a map of  the rays that intersect\n"]]},{"start1":2582,"length1":45,"diffs":[[1,"        this.reflectIndex = //Math.random()\n"]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":68,"length1":57,"diffs":[[1,"    intersections:{hx:number,hy:number}[] = []\n"]]}]}]},{"timestamp":1743016062169,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":69,"length1":87,"diffs":[[1,"    export const ARCADE_SCREEN_WIDTH = 320\n    export const ARCADE_SCREEN_HEIGHT = 240\n"]]},{"start1":199,"length1":31,"diffs":[[1,"const DRAW_DEBUG_LINES = true\n"]]},{"start1":573,"length1":128,"diffs":[[1,""]]},{"start1":587,"length1":109,"diffs":[[1,"        const col = Math.floor(this.x / 16)\n"]]},{"start1":1951,"length1":80,"diffs":[[1,"        const col = Math.round(mx / 16)\n        const row = Math.round(my / 16)\n"]]},{"start1":2780,"length1":92,"diffs":[[1,"        for (let i = -32; i < 32; i += 5) {\n            for (let k = -32; k < 32; k += 5) {\n"]]},{"start1":4358,"length1":52,"diffs":[[1,"    scene.setBackgroundImage(image.create(320,240))\n"]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":2340,"diffs":[[1,"        \"data\": \"MTAxODAwMTgwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjAyMjIyMjIyMDIwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAwMDAyMjIyMDIwMDAwMjAwMjAwMDAwMDAwMDAyMDIyMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMjIyMjIyMDAwMDAwMjIwMDAwMDAyMDIyMjIyMjIyMjIwMjAwMjIwMDAwMDAyMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAyMDAwMDAwMDAyMjIyMDIwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMA==\",\n"]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":304,"length1":1225,"diffs":[[1,"            case \"level1\":return tiles.createTilemap(hex`18001800010101010101010101010101010100000000000000000000010101010101010101010101010001010101010101000000000000000000000000010101010000000000000001010000000000000000000000000101010101000000000000010100000000000000000000000001010101010000000000000100000000000000000000000000000001010000000000000100000000000000000000000000000000010000000000000001000000000000000000000000000000010000000000000001000000000000000000000000000000010000000000000001000000000000000000000000000000010000000000000001010000000000000000000000000000010000000000000001010100000000000000000000000000010000000000000001010101010101010100000000000001010000000000000001010101010101010101010100000001010000000000000001010000000000000101010101010101010000000000000001010000000000000000000101010101000000000000000001010000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000001010100000000000000000000000000000000010101010101000100000000000000000101010101010101000000000000000101010101010101010000000000000000000000000000`, img`\n"]]},{"start1":1729,"length1":50,"diffs":[[1,"...............2.......2\n...............2.......2\n"]]},{"start1":1954,"length1":50,"diffs":[[1,""]]},{"start1":2004,"length1":0,"diffs":[[1,"2......................2\n2......................2\n"]]}]}]},{"timestamp":1743016633683,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2515,"length1":42,"diffs":[[1,""]]},{"start1":2974,"length1":114,"diffs":[[1,"        for (let i = -32; i < 32; i += 2) {\n            for (let k = -32; k < 32; k += 2) {\n"]]}]}]},{"timestamp":1743016798837,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4731,"length1":0,"diffs":[[1,"for (let i = 0; i < 5; i++) {\n    const M_ = new Mirror(Math.random() * 320, Math.random() * 240)\n}"]]}]}]},{"timestamp":1743034933547,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3308,"length1":12,"diffs":[[1,""]]}]}]},{"timestamp":1743034938666,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":199,"length1":30,"diffs":[[1,"const DRAW_DEBUG_LINES = false\n"]]},{"start1":574,"length1":0,"diffs":[[1,"    // this should be optmised , and have better collsions to make light rays not go through walls to increase shadow accuracy.\n"]]},{"start1":716,"length1":158,"diffs":[[1,"        const col = Math.floor(this.x / 16) // does Math.floor make it more accurate compared to Math.round?\n        const row = Math.floor(this.y / 16)\n"]]},{"start1":944,"length1":20,"diffs":[[1,"            return\n"]]},{"start1":973,"length1":2129,"diffs":[[1,"         let it = 0\n         while (true) {\n         const col = Math.round(this.x / 16)\n         const row = Math.round(this.y / 16)\n         if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col,row))) {\n          this.light.lightMap.push({hx:this.x,hy:this.y,dt:this.dist})\n          scene.backgroundImage().fillCircle(this.x,this.y,1,2)\n          break; \n         }\n          if (it>30 || this.vx == 0 && this.vy == 0) {\n              break; // to many iterations.\n          }\n         const ox = this.x\n         const oy = this.y\n         this.x += this.vx\n         this.y += this.vy\n         this.dist += (Math.abs(this.vx) + Math.abs(this.vy))\n         this.ckeckForMirrors(ox,oy)\n         if (DRAW_DEBUG_LINES) {\n            scene.backgroundImage().drawLine(ox,oy,this.x,this.y,1)\n         }\n         it++\n         }\n"]]},{"start1":1807,"length1":1,"diffs":[[1,""]]},{"start1":1984,"length1":0,"diffs":[[1,"        rt.mirrors.forEach((a, b) => a.doesReflectRay_(this,mx,my))\n"]]},{"start1":3308,"length1":0,"diffs":[[1,"// these do\n"]]},{"start1":3335,"length1":361,"diffs":[[1,"    x:number\n    y:number\n    reflectIndex:number\n    constructor(x:number,y:number) {\n        this.x = x\n        this.y = y\n        this.reflectIndex = 2//Math.random()\n        game.onShade(function () {\n            this.render()\n        })\n"]]},{"start1":3583,"length1":53,"diffs":[[1,""]]},{"start1":3598,"length1":98,"diffs":[[1,"        scene.backgroundImage().fillCircle(this.x,this.y,5,3)\n"]]},{"start1":3666,"length1":1186,"diffs":[[1,"    doesReflectRay(ray:Ray) {\n        const dist = Math.abs(ray.x - this.x) + Math.abs(ray.y - this.y)\n        if (dist < 6) {\n            if (Math.random() > this.reflectIndex) {\n              // stop the ray , it will destroy itself soon.\n              ray.vx = 0\n              ray.vy = 0\n            } else { // reflect it!\n              ray.vx = (-ray.vx) + Math.random()\n              ray.vy = (-ray.vy) + Math.random()\n"]]},{"start1":4105,"length1":0,"diffs":[[1,"\n"]]},{"start1":4122,"length1":0,"diffs":[[1,"    doesReflectRay_(ray: Ray,x:number,y:number) {\n        const dist = Math.abs(x - this.x) + Math.abs(y - this.y)\n        if (dist < 5) {\n            if (Math.random() > this.reflectIndex) {\n                // stop the ray , it will destroy itself soon.\n                ray.vx = 0\n                ray.vy = 0\n            } else { // reflect it!\n                ray.vx = (-ray.vx) + Math.random()\n                ray.vy = (-ray.vy) + Math.random()\n            }\n"]]},{"start1":4584,"length1":144,"diffs":[[1,"        }\n"]]},{"start1":4600,"length1":166,"diffs":[[1,""]]},{"start1":4602,"length1":1,"diffs":[[1,""]]},{"start1":4743,"length1":99,"diffs":[[1,""]]}]}]},{"timestamp":1743035525797,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3103,"length1":134,"diffs":[[1,"        rt.mirrors.forEach((a,b) => a.doesReflectRay(this))\n"]]},{"start1":3626,"length1":42,"diffs":[[1,"const RAY_ACCURACY = 6 // or low accuracy\n"]]},{"start1":3874,"length1":44,"diffs":[[1,"        rt.addlight(this) // add this light\n"]]},{"start1":6680,"length1":70,"diffs":[[1,"    const M = new Mirror(Math.random() * 320 , Math.random() * 240)\n"]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":18,"length1":191,"diffs":[[1,"    lights:Light[] = []\n    mirrors:Mirror[] = []\n    intersections:{hx:number,hy:number,dt:number}[] = []\n"]]},{"start1":145,"length1":183,"diffs":[[1,"      game.onShade(function() {\n          this.update()\n      })   \n"]]},{"start1":219,"length1":61,"diffs":[[1,""]]},{"start1":234,"length1":56,"diffs":[[1,"        this.intersections = []\n"]]},{"start1":280,"length1":444,"diffs":[[1,"           for (let i = 0; i < this.lights.length - 1; i++) {\n               const intersections_ = this.lights[i].lightMap // get the intersections\n               intersections_.forEach((a,b) => this.intersections.push(a)) // and push them onto this RayTracer's list\n            }\n"]]},{"start1":584,"length1":116,"diffs":[[1,"            console.log(\"Error during RayTracing:\" + e)\n            this.reset() // then reset, to advoid another crash\n"]]},{"start1":720,"length1":488,"diffs":[[1,"    addlight(Light:Light) {\n        this.lights.push(Light)\n        console.log(\"rays predicted to be shoot each frame:\" + 163 * this.lights.length)\n"]]},{"start1":875,"length1":312,"diffs":[[1,"    addMirror(Mirror:Mirror) {\n        this.mirrors.push(Mirror)\n"]]},{"start1":946,"length1":309,"diffs":[[1,""]]},{"start1":960,"length1":113,"diffs":[[1,"        this.lights = []\n        this.intersections = []\n"]]},{"start1":1023,"length1":2,"diffs":[[1,"}"]]}]}]},{"timestamp":1743035996735,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":158,"length1":79,"diffs":[[1,"tiles.setCurrentTilemap(tilemap`level1`)\nconst DRAW_DEBUG_LINES = true\n"]]},{"start1":587,"length1":66,"diffs":[[1,""]]},{"start1":1027,"length1":98,"diffs":[[1,"            const col = Math.round(this.x / 16);\n            const row = Math.round(this.y / 16);\n"]]},{"start1":1334,"length1":156,"diffs":[[1,"                scene.backgroundImage().fillCircle(this.x, this.y, 1, 2);\n"]]},{"start1":1515,"length1":67,"diffs":[[1,"            if (it > 30 || (this.vx === 0 && this.vy === 0)) {\n"]]},{"start1":2500,"length1":166,"diffs":[[1,"                    scene.backgroundImage().fillCircle(this.x, this.y, 1, 2);\n"]]},{"start1":3029,"length1":0,"diffs":[[1,"        const mx = (ox + this.x) / 2\n        const my = (oy + this.y) / 2\n"]]},{"start1":3236,"length1":0,"diffs":[[1,"\n        // a bit akward to do this here , but needed to keep rays from passing through walls\n        const col = Math.floor(mx / 16)\n        const row = Math.floor(my / 16)\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist })\n            scene.backgroundImage().fillCircle(this.x, this.y, 1, 2)\n            this.vx = 0\n            this.vy = 0\n        }\n"]]},{"start1":3700,"length1":42,"diffs":[[1,"const RAY_ACCURACY = 2 // or low accuracy\n"]]},{"start1":4801,"length1":27,"diffs":[[1,""]]},{"start1":5297,"length1":57,"diffs":[[1,"        if (distance < 6) { // Within interaction range\n"]]},{"start1":5914,"length1":144,"diffs":[[1,"                ray.vx = ray.vx - 2 * dotProduct * unitNormalX + Math.random() * 0.05; // Add slight randomness for effect\n                ray.vy = ray.vy - 2 * dotProduct * unitNormalY + Math.random() * 0.05;\n"]]},{"start1":6247,"length1":49,"diffs":[[1,""]]},{"start1":6664,"length1":158,"diffs":[[1,"const l = new Light(Math.random() * 30, Math.random() * 30)\nfor (let i = 0; i < 5; i++) {\n    const M = new Mirror(Math.random() * 320 , Math.random() * 240,1)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":302,"length1":86,"diffs":[[1,"        \"raytracer.ts\"\n"]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":4132,"diffs":[[1,"        \"data\": \"MTAxODAwMTgwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjAyMjIyMjIyMDIwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAwMDAyMjIyMDIwMDAwMjAwMjAwMDAwMDAwMDAyMDIyMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMjIyMjIyMDAwMDAwMjIwMDAwMDAyMDIyMjIyMjIyMjIwMjAwMjIwMDAwMDAyMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAyMDAwMDAwMDAyMjIyMDIwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMA==\",\n"]]},{"start1":2881,"length1":4409,"diffs":[[1,""]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":304,"length1":3177,"diffs":[[1,"            case \"level1\":return tiles.createTilemap(hex`18001800010101010101010101010101010100000000000000000000010101010101010101010101010001010101010101000000000000000000000000010101010000000000000001010000000000000000000000000101010101000000000000010100000000000000000000000001010101010000000000000100000000000000000000000000000001010000000000000100000000000000000000000000000000010000000000000001000000000000000000000000000000010000000000000001000000000000000001010100000000010000000000000001000000000000000001010100000000010000000000000001010000000000000000000000000000010000000000000001010100000000000000000000000000010000000000000001010101010101010100000000000001010000000000000001010101010101010101010100000001010000000000000001010000000000000101010101010101010000000000000001010000000000000000000101010101000000000000000001010000000000000000000000000000000000000000000001010000010101010100000000000000000000000000000001010000010101010100000000000000000000000000000001010000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000001010100000000000000000000000000000000010101010101000100000000000000000101010101010101000000000000000101010101010101010000000000000000000000000000`, img`\n22222222222222..........\n2222222222222.2222222...\n.........2222.......22..\n..........22222......22.\n...........22222......2.\n..............22......2.\n...............2.......2\n...............2.......2\n........222....2.......2\n........222....2.......2\n2..............2.......2\n22.............2.......2\n22222222......22.......2\n22222222222...22.......2\n2......222222222.......2\n2.........22222........2\n2......................2\n2..22222...............2\n2..22222...............2\n2......................2\n2......................2\n22................222222\n.2........22222222......\n.222222222..............\n"]]},{"start1":2204,"length1":3304,"diffs":[[1,""]]}]},{"type":"edited","filename":"raytracer_class.ts","patch":[{"start1":0,"length1":47,"diffs":[[1,""]]},{"start1":2063,"length1":103,"diffs":[[1,"        console.log(\"Rays predicted to be shot each frame: \" + (163 * this.lights.length));\n"]]},{"start1":2249,"length1":38,"diffs":[[1,""]]},{"start1":2297,"length1":26,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"if (game.ask(\"Map 1?\")) {\n    tiles.setCurrentTilemap(tilemap`level1`)\n} else {\n\n    tiles.setCurrentTilemap(tilemap`level2`)\n}\n// nothing else , the rest is handled in the raytracer"},{"type":"added","filename":"map_image_attached_to_tilemap.ts","value":"/** \n * for configuring the raytracer \n*/\nnamespace raytracer {\n   const scaler = 100 / 15\n   let normalmap:Image = image.create(1,1)\n   let array2d:number[][] = [[]]\n   let enabled_ = true\n   function scaleImageTo2dArray() {    \n    for (let i = 0; i < normalmap.width; i++) {\n      const d:number[] = []\n\n    for (let k = 0; k < normalmap.height; k++) {\n        const c = normalmap.getPixel(i,k) * scaler // get the value and scale it to 0-100\n        d.push(c)\n    }\n      array2d.push(d)\n    }\n   }\n   export function SetRaytracerEnabled(enabled:boolean) {\n      enabled_ = enabled\n   }\n   export function SetCurrentTileMapNormalMap(map:Image) {\n       normalmap = map\n       scaleImageTo2dArray() // then update the 2d array that's faster to read from\n   }\n   export function _read(x:number,y:number) {\n       return array2d[x][y]\n   }\n   export function _enabled() {\n       return enabled_\n   }\n}"}]},{"timestamp":1746312644889,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":319,"length1":5,"diffs":[[1,""]]}]}]},{"timestamp":1746312664829,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":219,"length1":18,"diffs":[[1,"const MAX_IT = 30\n"]]},{"start1":319,"length1":0,"diffs":[[1,"    \n"]]}]}]},{"timestamp":1749942401172,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":139,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"]NxQ[or1BiNA18uYE(rB\">mySprite</variable></variables><block type=\"pxt-on-start\" x=\"37\" y=\"46\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"class Ray {\" line1=\"    x:number\" line2=\"    y:number\" line3=\"    vx:number\" line4=\"    vy:number\" line5=\"    constructor() {}\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"maplocationistile\"><value name=\"location\"><shadow type=\"mapgettile\"><value name=\"col\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"row\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"tile\"><shadow type=\"tileset_tile_picker\"><field name=\"tile\">sprites.castle.tileGrass2</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>"]]}]}]},{"timestamp":1749942435825,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":395,"length1":44,"diffs":[[1,""]]}]}]}],"snapshots":[{"timestamp":1743009380846,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ray shooter\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1743016779678,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"]NxQ[or1BiNA18uYE(rB\">mySprite</variable></variables><block type=\"pxt-on-start\" x=\"37\" y=\"46\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"class Ray {\" line1=\"    x:number\" line2=\"    y:number\" line3=\"    vx:number\" line4=\"    vy:number\" line5=\"    constructor() {}\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"maplocationistile\"><value name=\"location\"><shadow type=\"mapgettile\"><value name=\"col\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"row\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"tile\"><shadow type=\"tileset_tile_picker\"><field name=\"tile\">sprites.castle.tileGrass2</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"namespace userconfig { //expand screen so more of the map is visible\n    export const ARCADE_SCREEN_WIDTH = 480\n    export const ARCADE_SCREEN_HEIGHT = 320\n}\ntiles.setCurrentTilemap(tilemap`level1`)\nconst DRAW_DEBUG_LINES = false\nclass Ray {\n    x:number\n    y:number\n    vx:number\n    vy:number\n    dist:number\n    private light:Light\n    constructor(x:number,y:number,vx:number,vy:number,light:Light) {\n      this.x = x\n      this.y = y\n      this.vx = vx\n      this.vy = vy\n      this.light = light \n      this.dist = 0\n      this.start() // start shooting the ray\n    }\n    // this should be optmised , and have better collsions to make light rays not go through walls to increase shadow accuracy.\n    start() {\n        const col = Math.floor(this.x / 16) // does Math.floor make it more accurate compared to Math.round?\n        const row = Math.floor(this.y / 16)\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            return\n        }\n         let it = 0\n         while (true) {\n         const col = Math.round(this.x / 16)\n         const row = Math.round(this.y / 16)\n         if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col,row))) {\n          this.light.lightMap.push({hx:this.x,hy:this.y,dt:this.dist})\n          scene.backgroundImage().fillCircle(this.x,this.y,1,2)\n          break; \n         }\n          if (it>30 || this.vx == 0 && this.vy == 0) {\n              break; // to many iterations.\n          }\n         const ox = this.x\n         const oy = this.y\n         this.x += this.vx\n         this.y += this.vy\n         this.dist += (Math.abs(this.vx) + Math.abs(this.vy))\n         this.ckeckForMirrors(ox,oy)\n         if (DRAW_DEBUG_LINES) {\n            scene.backgroundImage().drawLine(ox,oy,this.x,this.y,1)\n         }\n         it++\n         }\n    }\n    ckeckForMirrors(ox:number,oy:number) {\n        const mx = (ox + this.x) / 2\n        const my = (oy + this.y) / 2\n        rt.mirrors.forEach((a,b) => a.doesReflectRay(this))\n        rt.mirrors.forEach((a, b) => a.doesReflectRay_(this,mx,my))\n        // a bit akward to do this here , but needed to keep rays from passing through walls\n        const col = Math.floor(mx / 16)\n        const row = Math.floor(my / 16)\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist })\n            scene.backgroundImage().fillCircle(this.x, this.y, 1, 2)\n            this.vx = 0\n            this.vy = 0\n        }\n    }\n}\nconst RAY_ACCURACY = \nclass Light {\n    x:number\n    y:number\n    lightMap: {hx:number,hy:number,dt:number}[] = [] // a map of  the rays that intersect\n    constructor(x:number,y:number) { \n        this.x = x\n        this.y = y\n        rt.addlight(this) // add this light\n        game.onShade(function() {\n            this.lightMap = [] // clear it\n            this.light()\n            this.x += controller.dx()\n            this.y += controller.dy()\n        })\n    }\n    light() {\n        for (let i = -32; i < 32; i += 2) {\n            for (let k = -32; k < 32; k += 2) {\n                const ray = new Ray(this.x,this.y,i,k,this) // it will shoot itself\n            }\n        }\n        scene.backgroundImage().fillCircle(this.x,this.y,5,2)\n    }\n}\nclass Mirror {\n    x:number\n    y:number\n    reflectIndex:number\n    constructor(x:number,y:number) {\n        this.x = x\n        this.y = y\n        this.reflectIndex = 2//Math.random()\n        game.onShade(function () {\n            this.render()\n        })\n    }\n    render() {\n        scene.backgroundImage().fillCircle(this.x,this.y,5,3)\n    }\n    doesReflectRay(ray:Ray) {\n        const dist = Math.abs(ray.x - this.x) + Math.abs(ray.y - this.y)\n        if (dist < 6) {\n            if (Math.random() > this.reflectIndex) {\n              // stop the ray , it will destroy itself soon.\n              ray.vx = 0\n              ray.vy = 0\n            } else { // reflect it!\n              ray.vx = (-ray.vx) + Math.random()\n              ray.vy = (-ray.vy) + Math.random()\n            }\n\n        }\n    }\n    doesReflectRay_(ray: Ray,x:number,y:number) {\n        const dist = Math.abs(x - this.x) + Math.abs(y - this.y)\n        if (dist < 5) {\n            if (Math.random() > this.reflectIndex) {\n                // stop the ray , it will destroy itself soon.\n                ray.vx = 0\n                ray.vy = 0\n            } else { // reflect it!\n                ray.vx = (-ray.vx) + Math.random()\n                ray.vy = (-ray.vy) + Math.random()\n            }\n\n        }\n    }\n}\ngame.onPaint(function() {\n    scene.setBackgroundImage(image.create(480,320))\n})\nconst l = new Light(Math.random() * 30, Math.random() * 30)\nfor (let i = 0; i < 5; i++) {\n    const M_ = new Mirror(Math.random() * 320, Math.random() * 240)\n}","README.md":" ","assets.json":"","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxODAwMTgwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjAyMjIyMjIyMDIwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAwMDAyMjIyMDIwMDAwMjAwMjAwMDAwMDAwMDAyMDIyMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMjIyMjIyMDAwMDAwMjIwMDAwMDAyMDIyMjIyMjIyMjIwMjAwMjIwMDAwMDAyMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAyMDAwMDAwMDAyMjIyMDIwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","raytracer_class.ts":"class RayTracer {\n    lights:Light[] = []\n    mirrors:Mirror[] = []\n    intersections:{hx:number,hy:number,dt:number}[] = []\n    constructor() {\n      game.onShade(function() {\n          this.update()\n      })   \n    }\n    update() {\n        this.intersections = []\n        try {\n           for (let i = 0; i < this.lights.length - 1; i++) {\n               const intersections_ = this.lights[i].lightMap // get the intersections\n               intersections_.forEach((a,b) => this.intersections.push(a)) // and push them onto this RayTracer's list\n            }\n        } catch (e) {\n            console.log(\"Error during RayTracing:\" + e)\n            this.reset() // then reset, to advoid another crash\n        }\n    }\n    addlight(Light:Light) {\n        this.lights.push(Light)\n        console.log(\"rays predicted to be shoot each frame:\" + 163 * this.lights.length)\n    }\n    addMirror(Mirror:Mirror) {\n        this.mirrors.push(Mirror)\n    }\n    reset() {\n        this.lights = []\n        this.intersections = []\n    }\n}","raytracer.ts":"const rt = new RayTracer()\r\n","pxt.json":"{\n    \"name\": \"ray shooter (IE:2d raytracer)\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\",\n        \"raytracer_class.ts\",\n        \"raytracer.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1743119352099,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"]NxQ[or1BiNA18uYE(rB\">mySprite</variable></variables><block type=\"pxt-on-start\" x=\"37\" y=\"46\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"class Ray {\" line1=\"    x:number\" line2=\"    y:number\" line3=\"    vx:number\" line4=\"    vy:number\" line5=\"    constructor() {}\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"maplocationistile\"><value name=\"location\"><shadow type=\"mapgettile\"><value name=\"col\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"row\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"tile\"><shadow type=\"tileset_tile_picker\"><field name=\"tile\">sprites.castle.tileGrass2</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"namespace userconfig { //expand screen so more of the map is visible\n    export const ARCADE_SCREEN_WIDTH = 480\n    export const ARCADE_SCREEN_HEIGHT = 320\n}\ntiles.setCurrentTilemap(tilemap`level1`)\nconst DRAW_DEBUG_LINES = true\nclass Ray {\n    x:number\n    y:number\n    vx:number\n    vy:number\n    dist:number\n    private light:Light\n    constructor(x:number,y:number,vx:number,vy:number,light:Light) {\n      this.x = x\n      this.y = y\n      this.vx = vx\n      this.vy = vy\n      this.light = light \n      this.dist = 0\n      this.start() // start shooting the ray\n    }\n    start() {\n        const col = Math.floor(this.x / 16);\n        const row = Math.floor(this.y / 16);\n\n        // Check if the starting position is already inside a wall\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            return;\n        }\n\n        let it = 0; // Iteration counter\n        const steps = 4; // Number of sub-steps per movement\n        while (true) {\n            // Calculate the current tile position\n            const col = Math.round(this.x / 16);\n            const row = Math.round(this.y / 16);\n\n            // Check if the ray hits a wall\n            if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n                this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                scene.backgroundImage().fillCircle(this.x, this.y, 1, 2);\n                break;\n            }\n\n            // Break if too many iterations or the ray is not moving\n            if (it > 30 || (this.vx === 0 && this.vy === 0)) {\n                break;\n            }\n\n            // Sub-stepping logic\n            const stepVx = this.vx / steps;\n            const stepVy = this.vy / steps;\n            for (let i = 0; i < steps; i++) {\n                const prevX = this.x;\n                const prevY = this.y;\n                this.x += stepVx;\n                this.y += stepVy;\n                this.dist += Math.sqrt(stepVx * stepVx + stepVy * stepVy);\n\n                // Check for collision at the intermediate step\n                const subCol = Math.floor(this.x / 16);\n                const subRow = Math.floor(this.y / 16);\n                if (tiles.tileAtLocationIsWall(tiles.getTileLocation(subCol, subRow))) {\n                    // Reset position to avoid skipping over the wall\n                    this.x = prevX;\n                    this.y = prevY;\n                    this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                    scene.backgroundImage().fillCircle(this.x, this.y, 1, 2);\n                    this.vx = 0;\n                    this.vy = 0; // Stop the ray\n                    return;\n                }\n            }\n\n            // Draw debug lines if enabled\n            if (DRAW_DEBUG_LINES) {\n                scene.backgroundImage().drawLine(this.x - this.vx, this.y - this.vy, this.x, this.y, 1);\n            }\n\n            it++; // Increment iteration counter\n        }\n    }\n\n    ckeckForMirrors(ox:number,oy:number) {\n        const mx = (ox + this.x) / 2\n        const my = (oy + this.y) / 2\n        rt.mirrors.forEach((mirror) => {\n            mirror.doesReflectRay(this); // Pass the ray instance to the mirror\n        });\n\n        // a bit akward to do this here , but needed to keep rays from passing through walls\n        const col = Math.floor(mx / 16)\n        const row = Math.floor(my / 16)\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist })\n            scene.backgroundImage().fillCircle(this.x, this.y, 1, 2)\n            this.vx = 0\n            this.vy = 0\n        }\n    }\n}\nconst RAY_ACCURACY = 2 // or low accuracy\nclass Light {\n    x:number\n    y:number\n    lightMap: {hx:number,hy:number,dt:number}[] = [] // a map of  the rays that intersect\n    constructor(x:number,y:number) { \n        this.x = x\n        this.y = y\n        rt.addLight(this) // add this light\n        game.onShade(function() {\n            this.lightMap = [] // clear it\n            this.light()\n            this.x += controller.dx()\n            this.y += controller.dy()\n        })\n    }\n    light() {\n        for (let i = -32; i < 32; i += RAY_ACCURACY) {\n            for (let k = -32; k < 32; k += RAY_ACCURACY) {\n                const ray = new Ray(this.x,this.y,i,k,this) // it will shoot itself\n            }\n        }\n        scene.backgroundImage().fillCircle(this.x,this.y,5,2)\n    }\n}\nclass Mirror {\n    x: number;\n    y: number;\n    reflectIndex: number; // Determines probability of reflection (0-1)\n\n    constructor(x: number, y: number, reflectIndex: number = 0.5) {\n        this.x = x;\n        this.y = y;\n        this.reflectIndex = reflectIndex ; // Allow customization during creation\n        game.onShade(() => {\n            this.render();\n        });\n    }\n\n    // Render the mirror's appearance on the screen\n    render() {\n        scene.backgroundImage().fillCircle(this.x, this.y, 5, 3); // Mirror visual representation\n    }\n\n    // Reflect or stop the ray based on proximity and reflection index\n    handleRayInteraction(ray: Ray, mx: number, my: number) {\n        const distance = Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2); // Use Euclidean distance for precision\n        if (distance < 6) { // Within interaction range\n            if (Math.random() <= this.reflectIndex) {\n                // Reflect the ray based on mirror logic\n                const normalX = this.x - ray.x; // Calculate normal direction\n                const normalY = this.y - ray.y;\n                const magnitude = Math.sqrt(normalX ** 2 + normalY ** 2);\n                const unitNormalX = normalX / magnitude;\n                const unitNormalY = normalY / magnitude;\n\n                // Reflect the ray using normal vector\n                const dotProduct = ray.vx * unitNormalX + ray.vy * unitNormalY;\n                ray.vx = ray.vx - 2 * dotProduct * unitNormalX + Math.random() * 0.05; // Add slight randomness for effect\n                ray.vy = ray.vy - 2 * dotProduct * unitNormalY + Math.random() * 0.05;\n            } else {\n                // Stop the ray\n                ray.vx = 0;\n                ray.vy = 0;\n            }\n        }\n    }\n\n    // Simplified method for checking interaction directly\n    doesReflectRay(ray: Ray) {\n        this.handleRayInteraction(ray, ray.x, ray.y);\n    }\n\n    // Extended method for midpoint interaction\n    doesReflectRayMidpoint(ray: Ray, mx: number, my: number) {\n        this.handleRayInteraction(ray, mx, my);\n    }\n}\n\ngame.onPaint(function() {\n    scene.setBackgroundImage(image.create(480,320))\n})\nconst l = new Light(Math.random() * 30, Math.random() * 30)\nfor (let i = 0; i < 5; i++) {\n    const M = new Mirror(Math.random() * 320 , Math.random() * 240,1)\n}","README.md":" ","assets.json":"","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxODAwMTgwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjAyMjIyMjIyMDIwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAwMDAyMjIyMDIwMDAwMjAwMjAwMDAwMDAwMDAyMDIyMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMjAwMDAwMDAyMDIyMjIyMjIyMDAwMDAwMjIwMDAwMDAyMDIyMjIyMjIyMjIwMjAwMjIwMDAwMDAyMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAyMDAwMDAwMDAyMjIyMDIwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMjAyMjIyMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","raytracer_class.ts":"class RayTracer {\n    lights: Light[] = [];\n    mirrors: Mirror[] = [];\n    intersections: { hx: number; hy: number; dt: number }[] = []; // Unique intersections\n    lightMap: Image; // 2D image for lighting\n\n    constructor() {\n        this.lightMap = image.create(480, 320); // Match your screen dimensions\n        game.onShade(() => {\n            this.update();\n            this.renderLightMap();\n        });\n    }\n\n    // Update method: Computes intersections for all lights\n    update() {\n        this.intersections = []; // Clear intersections\n        try {\n            this.lights.forEach(light => {\n                const lightIntersections = light.lightMap; // Get intersections from the light\n                lightIntersections.forEach(intersection => {\n                    // Add only unique intersections\n                    if (!this.isDuplicateIntersection(intersection)) {\n                        this.intersections.push(intersection);\n                    }\n                });\n            });\n        } catch (e) {\n            console.log(\"Error during RayTracing: \" + e);\n            this.reset(); // Reset to avoid another crash\n        }\n    }\n\n    // Generate and render the light map\n    renderLightMap() {\n        this.lightMap.fill(0); // Clear the light map (all black)\n        this.intersections.forEach(intersection => {\n            const brightness = Math.min(Math.max(0, 255 - intersection.dt * 10),15); // Decrease brightness with distance\n            this.lightMap.setPixel(intersection.hx, intersection.hy, brightness);\n        });\n        scene.setBackgroundImage(this.lightMap); // Update the scene with the light map\n    }\n\n    // Check for duplicate intersections\n    isDuplicateIntersection(intersection: { hx: number; hy: number; dt: number }): boolean {\n        return this.intersections.some(existing =>\n            Math.abs(existing.hx - intersection.hx) < 1 &&\n            Math.abs(existing.hy - intersection.hy) < 1\n        );\n    }\n\n    // Add a light source\n    addLight(light: Light) {\n        this.lights.push(light);\n        console.log(\"Rays predicted to be shot each frame: \" + (163 * this.lights.length));\n    }\n\n    // Add a mirror\n    addMirror(mirror: Mirror) {\n        this.mirrors.push(mirror);\n    }\n\n    // Reset the raytracer\n    reset() {\n        this.lights = [];\n        this.intersections = [];\n        this.lightMap.fill(0); // Clear the light map\n    }\n}\n","raytracer.ts":"const rt = new RayTracer()\r\n","pxt.json":"{\n    \"name\": \"ray shooter (IE:2d raytracer)\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\",\n        \"raytracer_class.ts\",\n        \"raytracer.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746312644889,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"]NxQ[or1BiNA18uYE(rB\">mySprite</variable></variables><block type=\"pxt-on-start\" x=\"37\" y=\"46\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"class Ray {\" line1=\"    x:number\" line2=\"    y:number\" line3=\"    vx:number\" line4=\"    vy:number\" line5=\"    constructor() {}\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"maplocationistile\"><value name=\"location\"><shadow type=\"mapgettile\"><value name=\"col\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"row\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"tile\"><shadow type=\"tileset_tile_picker\"><field name=\"tile\">sprites.castle.tileGrass2</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"namespace userconfig { //expand screen so more of the map is visible\n    export const ARCADE_SCREEN_WIDTH = 480\n    export const ARCADE_SCREEN_HEIGHT = 320\n}\n\nconst DRAW_DEBUG_LINES = false\nconst SHOW_COLLISIONS = true\nconst MAX_IT = 30\nclass Ray {\n    x:number\n    y:number\n    vx:number\n    vy:number\n    dist:number\n    private light:Light\n    constructor(x:number,y:number,vx:number,vy:number,light:Light) {\n      this.x = x\n      this.y = y\n      this.vx = vx\n      this.vy = vy\n      this.light = light \n      this.dist = 0\n      this.start() // start shooting the ray\n    }\n    start() {\n        if (!raytracer._enabled()) {\n            return\n        }\n        const col = Math.floor(this.x / 16);\n        const row = Math.floor(this.y / 16);\n\n        // Check if the starting position is already inside a wall\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            return;\n        }\n\n        let it = 0; // Iteration counter\n        const steps = 4; // Number of sub-steps per movement\n        while (true) {\n            // Calculate the current tile position\n            const col = Math.floor(this.x / 16);\n            const row = Math.floor(this.y / 16);\n\n            // Check if the ray hits a wall\n            if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n                this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                if (SHOW_COLLISIONS) { \n                   scene.backgroundImage().fillCircle(this.x, this.y, 1, 2) // show the collision\n                }\n                break;\n            }\n\n            // Break if too many iterations or the ray is not moving\n            if (it > MAX_IT || (this.vx === 0 && this.vy === 0)) {\n                break;\n            }\n\n            // Sub-stepping logic\n            const stepVx = this.vx / steps;\n            const stepVy = this.vy / steps;\n            for (let i = 0; i < steps; i++) {\n                const prevX = this.x;\n                const prevY = this.y;\n                this.x += stepVx;\n                this.y += stepVy;\n                this.dist += Math.sqrt(stepVx * stepVx + stepVy * stepVy);\n\n                // Check for collision at the intermediate step\n                const subCol = Math.floor(this.x / 16);\n                const subRow = Math.floor(this.y / 16);\n                if (tiles.tileAtLocationIsWall(tiles.getTileLocation(subCol, subRow))) {\n                    // Reset position to avoid skipping over the wall\n                    this.x = prevX;\n                    this.y = prevY;\n                    this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                    if (SHOW_COLLISIONS) {\n                      scene.backgroundImage().fillCircle(this.x, this.y, 1, 2) // show the collision\n                    }\n                    this.vx = 0;\n                    this.vy = 0; // Stop the ray\n                    return;\n                }\n            }\n\n            // Draw debug lines if enabled\n            if (DRAW_DEBUG_LINES) {\n                scene.backgroundImage().drawLine(this.x - this.vx, this.y - this.vy, this.x, this.y, 1);\n            }\n\n            it++; // Increment iteration counter\n        }\n    }\n\n    ckeckForMirrors(ox:number,oy:number) {\n        rt.mirrors.forEach((mirror) => {\n            mirror.doesReflectRay(this); // Pass the ray instance to the mirror\n        });\n    }\n}\nconst RAY_ACCURACY = 8 // or low accuracy\nclass Light {\n    x:number\n    y:number\n    lightMap: {hx:number,hy:number,dt:number}[] = [] // a map of  the rays that intersect\n    constructor(x:number,y:number) { \n        this.x = x\n        this.y = y\n        rt.addLight(this) // add this light\n        game.onShade(function() {\n            this.lightMap = [] // clear it\n            this.light()\n            this.x += controller.dx()\n            this.y += controller.dy()\n        })\n    }\n    light() {\n        for (let i = -32; i < 32; i += RAY_ACCURACY) {\n            for (let k = -32; k < 32; k += RAY_ACCURACY) {\n                const ray = new Ray(this.x,this.y,i,k,this) // it will shoot itself\n            }\n        }\n        scene.backgroundImage().fillCircle(this.x,this.y,5,2)\n    }\n}\nclass Mirror {\n    x: number;\n    y: number;\n    reflectIndex: number; // Determines probability of reflection (0-1)\n\n    constructor(x: number, y: number, reflectIndex: number = 0.5) {\n        this.x = x;\n        this.y = y;\n        this.reflectIndex = reflectIndex ; // Allow customization during creation\n        rt.addMirror(this)\n        game.onShade(() => {\n            this.render();\n        });\n    }\n\n    // Render the mirror's appearance on the screen\n    render() {\n        scene.backgroundImage().fillCircle(this.x, this.y, 5, 3); // Mirror visual representation\n    }\n\n    // Reflect or stop the ray based on proximity and reflection index\n    handleRayInteraction(ray: Ray, mx: number, my: number) {\n        const distance = Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2); // Use Euclidean distance for precision\n        if (distance < 16) { // Within interaction range\n            if (Math.random() <= this.reflectIndex) {\n                // Reflect the ray based on mirror logic\n                const normalX = this.x - ray.x; // Calculate normal direction\n                const normalY = this.y - ray.y;\n                const magnitude = Math.sqrt(normalX ** 2 + normalY ** 2);\n                const unitNormalX = normalX / magnitude;\n                const unitNormalY = normalY / magnitude;\n\n                // Reflect the ray using normal vector\n                const dotProduct = ray.vx * unitNormalX + ray.vy * unitNormalY;\n                ray.vx = ray.vx - 2 * dotProduct * unitNormalX // then apply it\n                ray.vy = ray.vy - 2 * dotProduct * unitNormalY \n            } else {\n                // Stop the ray\n                ray.vx = 0;\n                ray.vy = 0;\n            }\n        } else {\n            return // just exit\n        }\n    }\n\n    // Simplified method for checking interaction directly\n    doesReflectRay(ray: Ray) {\n        this.handleRayInteraction(ray, ray.x, ray.y);\n    }\n\n    // Extended method for midpoint interaction\n    doesReflectRayMidpoint(ray: Ray, mx: number, my: number) {\n        this.handleRayInteraction(ray, mx, my);\n    }\n}\n\ngame.onPaint(function() {\n    scene.setBackgroundImage(image.create(480,320))\n})\nconst l = new Light(Math.random() * 320, Math.random() * 320)\nfor (let i = 0; i < 3; i++) {\n    const l = new Light(Math.random() * 320, Math.random() * 320)\n}","README.md":" ","assets.json":"","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAyMDAwMjAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDEwMTAxMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAwMDAwMTAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAxMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAxMDEwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAyMjIyMjIyMjIyMjIwMjIyMjIyMjAyMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAyMDAwMDAwMDAwMDIyMjIwMjAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjIyMDAwMDAwMDIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDIwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAwMjAwMDAwMDAwMDAwMDAyMjAyMDAyMDAwMDAwMDIwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDIwMDAwMDAwMjAwMDAyMDAwMDIyMDAwMDAwMDAwMDAwMjAwMDIyMDIyMDAwMDAwMDAwMjIyMjIyMjIwMDAwMDAyMjAwMjIwMjIwMjAwMDAwMDAyMjIyMjIyMjIyMDIwMDIyMDAwMDAwMjAwMDAwMDAwMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAwMDIwMDAwMDIwMDAwMDAwMDIyMjIwMjAwMDAwMDIwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMjAwMDIwMDAwMDAyMjAyMjIyMDAwMDAwMDAyMDAwMDAyMDAwMDAwMDAwMDIyMDIyMjIwMDIwMDAyMDAwMDAwMDIwMDAwMDAyMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAyMDAwMjAwMjAwMDAyMDAwMDAwMDAyMDAwMDAyMDAwMjIwMDAwMjAwMDAwMDAwMDAwMjIyMjIyMDAwMDAwMDAyMDAwMDAwMDAwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMjIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"level2\": {\n        \"id\": \"level2\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAyMDAwMjAwMDAxMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIwMjAyMDIwMjAyMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAyMDIwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjIwMDAwMjIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAyMjAwMDAyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDIwMjIwMDAwMjIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAyMjAwMDAyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDIwMjIyMjIyMDAwMDAwMDAwMDAwMDAyMDIyMDIwMDAwMDAwMDAwMDAyMjAyMDAwMDAwMDAyMjAyMDAwMjAwMDAwMDAwMDAwMDAwMjAwMjAwMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\",\n            \"sprites.swamp.swampTile1\"\n        ],\n        \"displayName\": \"level2\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","raytracer_class.ts":"const RAYS_PER_LIGHT = (65 * 2) / RAY_ACCURACY\nclass RayTracer {\n    lights: Light[] = [];\n    mirrors: Mirror[] = [];\n    intersections: { hx: number; hy: number; dt: number }[] = []; // Unique intersections\n    lightMap: Image; // 2D image for lighting\n\n    constructor() {\n        this.lightMap = image.create(480, 320); // Match your screen dimensions\n        game.onShade(() => {\n            this.update();\n            this.renderLightMap();\n        });\n    }\n\n    // Update method: Computes intersections for all lights\n    update() {\n        this.intersections = []; // Clear intersections\n        try {\n            this.lights.forEach(light => {\n                const lightIntersections = light.lightMap; // Get intersections from the light\n                lightIntersections.forEach(intersection => {\n                    // Add only unique intersections\n                    if (!this.isDuplicateIntersection(intersection)) {\n                        this.intersections.push(intersection);\n                    }\n                });\n            });\n        } catch (e) {\n            console.log(\"Error during RayTracing: \" + e);\n            this.reset(); // Reset to avoid another crash\n        }\n    }\n\n    // Generate and render the light map\n    renderLightMap() {\n        this.lightMap.fill(0); // Clear the light map (all black)\n        this.intersections.forEach(intersection => {\n            const brightness = Math.min(Math.max(0, 255 - intersection.dt * 10),15); // Decrease brightness with distance\n            this.lightMap.setPixel(intersection.hx, intersection.hy, brightness);\n        });\n        scene.setBackgroundImage(this.lightMap); // Update the scene with the light map\n    }\n\n    // Check for duplicate intersections\n    isDuplicateIntersection(intersection: { hx: number; hy: number; dt: number }): boolean {\n        return this.intersections.some(existing =>\n            Math.abs(existing.hx - intersection.hx) < 1 &&\n            Math.abs(existing.hy - intersection.hy) < 1\n        );\n    }\n\n    // Add a light source\n    addLight(light: Light) {\n        this.lights.push(light);\n        console.log(\"Rays predicted to be shot each frame: \" + (RAYS_PER_LIGHT * this.lights.length));\n    }\n\n    // Add a mirror\n    addMirror(mirror: Mirror) {\n        this.mirrors.push(mirror);\n        console.log(\"Mirror addded!\")\n    }\n\n    // Reset the raytracer\n    reset() {\n        this.mirrors = []\n        this.lights = [];\n        this.intersections = [];\n        this.lightMap.fill(0); // Clear the light map\n    }\n}\n","raytracer.ts":"const rt = new RayTracer()\r\n","test.ts":"if (game.ask(\"Map 1?\")) {\n    tiles.setCurrentTilemap(tilemap`level1`)\n} else {\n\n    tiles.setCurrentTilemap(tilemap`level2`)\n}\n// nothing else , the rest is handled in the raytracer","map_image_attached_to_tilemap.ts":"/** \n * for configuring the raytracer \n*/\nnamespace raytracer {\n   const scaler = 100 / 15\n   let normalmap:Image = image.create(1,1)\n   let array2d:number[][] = [[]]\n   let enabled_ = true\n   function scaleImageTo2dArray() {    \n    for (let i = 0; i < normalmap.width; i++) {\n      const d:number[] = []\n\n    for (let k = 0; k < normalmap.height; k++) {\n        const c = normalmap.getPixel(i,k) * scaler // get the value and scale it to 0-100\n        d.push(c)\n    }\n      array2d.push(d)\n    }\n   }\n   export function SetRaytracerEnabled(enabled:boolean) {\n      enabled_ = enabled\n   }\n   export function SetCurrentTileMapNormalMap(map:Image) {\n       normalmap = map\n       scaleImageTo2dArray() // then update the 2d array that's faster to read from\n   }\n   export function _read(x:number,y:number) {\n       return array2d[x][y]\n   }\n   export function _enabled() {\n       return enabled_\n   }\n}","pxt.json":"{\n    \"name\": \"ray shooter (IE:2d raytracer)\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\",\n        \"raytracer_class.ts\",\n        \"raytracer.ts\",\n        \"test.ts\",\n        \"map_image_attached_to_tilemap.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749942401172,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"]NxQ[or1BiNA18uYE(rB\">mySprite</variable></variables><block type=\"pxt-on-start\" x=\"37\" y=\"46\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"class Ray {\" line1=\"    x:number\" line2=\"    y:number\" line3=\"    vx:number\" line4=\"    vy:number\" line5=\"    constructor() {}\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"maplocationistile\"><value name=\"location\"><shadow type=\"mapgettile\"><value name=\"col\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"row\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"tile\"><shadow type=\"tileset_tile_picker\"><field name=\"tile\">sprites.castle.tileGrass2</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"namespace userconfig { //expand screen so more of the map is visible\n    export const ARCADE_SCREEN_WIDTH = 480\n    export const ARCADE_SCREEN_HEIGHT = 320\n}\n\nconst DRAW_DEBUG_LINES = false\nconst SHOW_COLLISIONS = true\nconst MAX_IT = 45\nclass Ray {\n    x:number\n    y:number\n    vx:number\n    vy:number\n    dist:number\n    private light:Light\n    constructor(x:number,y:number,vx:number,vy:number,light:Light) {\n      this.x = x\n      this.y = y\n      this.vx = vx\n      this.vy = vy\n      this.light = light \n      this.dist = 0\n      this.start() // start shooting the ray\n    }\n    start() {\n        if (!raytracer._enabled()) {\n            return\n        }\n        const col = Math.floor(this.x / 16);\n        const row = Math.floor(this.y / 16);\n\n        // Check if the starting position is already inside a wall\n        if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n            return;\n        }\n\n        let it = 0; // Iteration counter\n        const steps = 4; // Number of sub-steps per movement\n        while (true) {\n            // Calculate the current tile position\n            const col = Math.floor(this.x / 16);\n            const row = Math.floor(this.y / 16);\n\n            // Check if the ray hits a wall\n            if (tiles.tileAtLocationIsWall(tiles.getTileLocation(col, row))) {\n                this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                if (SHOW_COLLISIONS) { \n                   scene.backgroundImage().fillCircle(this.x, this.y, 1, 2) // show the collision\n                }\n                break;\n            }\n\n            // Break if too many iterations or the ray is not moving\n            if (it > MAX_IT || (this.vx === 0 && this.vy === 0)) {\n                break;\n            }\n\n            // Sub-stepping logic\n            const stepVx = this.vx / steps;\n            const stepVy = this.vy / steps;\n            for (let i = 0; i < steps; i++) {\n                const prevX = this.x;\n                const prevY = this.y;\n                this.x += stepVx;\n                this.y += stepVy;\n                this.dist += Math.sqrt(stepVx * stepVx + stepVy * stepVy);\n\n                // Check for collision at the intermediate step\n                const subCol = Math.floor(this.x / 16);\n                const subRow = Math.floor(this.y / 16);\n                if (tiles.tileAtLocationIsWall(tiles.getTileLocation(subCol, subRow))) {\n                    // Reset position to avoid skipping over the wall\n                    this.x = prevX;\n                    this.y = prevY;\n                    this.light.lightMap.push({ hx: this.x, hy: this.y, dt: this.dist });\n                    if (SHOW_COLLISIONS) {\n                      scene.backgroundImage().fillCircle(this.x, this.y, 1, 2) // show the collision\n                    }\n                    this.vx = 0;\n                    this.vy = 0; // Stop the ray\n                    return;\n                }\n            }\n\n            // Draw debug lines if enabled\n            if (DRAW_DEBUG_LINES) {\n                scene.backgroundImage().drawLine(this.x - this.vx, this.y - this.vy, this.x, this.y, 1);\n            }\n\n            it++; // Increment iteration counter\n        }\n    }\n\n    ckeckForMirrors(ox:number,oy:number) {\n        rt.mirrors.forEach((mirror) => {\n            mirror.doesReflectRay(this); // Pass the ray instance to the mirror\n        });\n    }\n}\nconst RAY_ACCURACY = 8 // or low accuracy\nclass Light {\n    x:number\n    y:number\n    lightMap: {hx:number,hy:number,dt:number}[] = [] // a map of  the rays that intersect\n    constructor(x:number,y:number) { \n        this.x = x\n        this.y = y\n        rt.addLight(this) // add this light\n        game.onShade(function() {\n            this.lightMap = [] // clear it\n            this.light()\n            this.x += controller.dx()\n            this.y += controller.dy()\n        })\n    }\n    light() {\n        for (let i = -32; i < 32; i += RAY_ACCURACY) {\n            for (let k = -32; k < 32; k += RAY_ACCURACY) {\n                const ray = new Ray(this.x,this.y,i,k,this) // it will shoot itself\n            }\n        }\n        scene.backgroundImage().fillCircle(this.x,this.y,5,2)\n    }\n}\nclass Mirror {\n    x: number;\n    y: number;\n    reflectIndex: number; // Determines probability of reflection (0-1)\n\n    constructor(x: number, y: number, reflectIndex: number = 0.5) {\n        this.x = x;\n        this.y = y;\n        this.reflectIndex = reflectIndex ; // Allow customization during creation\n        rt.addMirror(this)\n        game.onShade(() => {\n            this.render();\n        });\n    }\n\n    // Render the mirror's appearance on the screen\n    render() {\n        scene.backgroundImage().fillCircle(this.x, this.y, 5, 3); // Mirror visual representation\n    }\n\n    // Reflect or stop the ray based on proximity and reflection index\n    handleRayInteraction(ray: Ray, mx: number, my: number) {\n        const distance = Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2); // Use Euclidean distance for precision\n        if (distance < 16) { // Within interaction range\n            if (Math.random() <= this.reflectIndex) {\n                // Reflect the ray based on mirror logic\n                const normalX = this.x - ray.x; // Calculate normal direction\n                const normalY = this.y - ray.y;\n                const magnitude = Math.sqrt(normalX ** 2 + normalY ** 2);\n                const unitNormalX = normalX / magnitude;\n                const unitNormalY = normalY / magnitude;\n\n                // Reflect the ray using normal vector\n                const dotProduct = ray.vx * unitNormalX + ray.vy * unitNormalY;\n                ray.vx = ray.vx - 2 * dotProduct * unitNormalX // then apply it\n                ray.vy = ray.vy - 2 * dotProduct * unitNormalY \n            } else {\n                // Stop the ray\n                ray.vx = 0;\n                ray.vy = 0;\n            }\n        } else {\n            return // just exit\n        }\n    }\n\n    // Simplified method for checking interaction directly\n    doesReflectRay(ray: Ray) {\n        this.handleRayInteraction(ray, ray.x, ray.y);\n    }\n\n    // Extended method for midpoint interaction\n    doesReflectRayMidpoint(ray: Ray, mx: number, my: number) {\n        this.handleRayInteraction(ray, mx, my);\n    }\n}\n\ngame.onPaint(function() {\n    scene.setBackgroundImage(image.create(480,320))\n})\nconst l = new Light(Math.random() * 320, Math.random() * 320)\nfor (let i = 0; i < 3; i++) {\n    const l = new Light(Math.random() * 320, Math.random() * 320)\n}","README.md":" ","assets.json":"","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAyMDAwMjAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDEwMTAxMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTAxMDAwMDAxMDEwMTAwMDAwMTAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAxMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAxMDEwMTAxMDEwMDAwMDAwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMTAwMDAwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAxMDAwMDAxMDEwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAyMjIyMjIyMjIyMjIwMjIyMjIyMjAyMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjAyMDAwMDAwMjIwMDAwMDAwMDAyMDAwMDAwMDAwMDIyMjIwMjAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjIyMDAwMDAwMDIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDIwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjIwMjAwMjAwMDAwMDAyMDAwMjAwMDAwMDAwMDAwMDAyMjAyMDAyMDAwMDAwMDIwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDIwMDAwMDAwMjAwMDAyMDAwMDIyMDAwMDAwMDAwMDAwMjAwMDIyMDIyMDAwMDAwMDAwMjIyMjIyMjIwMDAwMDAyMjAwMjIwMjIwMjAwMDAwMDAyMjIyMjIyMjIyMDIwMDIyMDAwMDAwMjAwMDAwMDAwMDAyMDAwMDIwMjIyMjIyMjIwMDAwMDAyMDAwMDIwMDAwMDIwMDAwMDAwMDIyMjIwMjAwMDAwMDIwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMjAwMDIwMDAwMDAyMjAyMjIyMDAwMDAwMDAyMDAwMDAyMDAwMDAwMDAwMDIyMDIyMjIwMDIwMDAyMDAwMDAwMDIwMDAwMDAyMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAyMDAwMjAwMjAwMDAyMDAwMDAwMDAyMDAwMDAyMDAwMjIwMDAwMjAwMDAwMDAwMDAwMjIyMjIyMDAwMDAwMDAyMDAwMDAwMDAwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMjIwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"level2\": {\n        \"id\": \"level2\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAyMDAwMjAwMDAxMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIwMjAyMDIwMjAyMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAyMDIwMjAyMDIwMjAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMDIwMjAyMDIwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMDAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAwMDAwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjIwMDAwMjIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAyMjAwMDAyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDIwMjIwMDAwMjIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAyMjAwMDAyMDAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDIwMjIyMjIyMDAwMDAwMDAwMDAwMDAyMDIyMDIwMDAwMDAwMDAwMDAyMjAyMDAwMDAwMDAyMjAyMDAwMjAwMDAwMDAwMDAwMDAwMjAwMjAwMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIyMDAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\",\n            \"sprites.swamp.swampTile1\"\n        ],\n        \"displayName\": \"level2\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","raytracer_class.ts":"const RAYS_PER_LIGHT = (65 * 2) / RAY_ACCURACY\nclass RayTracer {\n    lights: Light[] = [];\n    mirrors: Mirror[] = [];\n    intersections: { hx: number; hy: number; dt: number }[] = []; // Unique intersections\n    lightMap: Image; // 2D image for lighting\n\n    constructor() {\n        this.lightMap = image.create(480, 320); // Match your screen dimensions\n        game.onShade(() => {\n            this.update();\n            this.renderLightMap();\n        });\n    }\n\n    // Update method: Computes intersections for all lights\n    update() {\n        this.intersections = []; // Clear intersections\n        try {\n            this.lights.forEach(light => {\n                const lightIntersections = light.lightMap; // Get intersections from the light\n                lightIntersections.forEach(intersection => {\n                    // Add only unique intersections\n                    if (!this.isDuplicateIntersection(intersection)) {\n                        this.intersections.push(intersection);\n                    }\n                });\n            });\n        } catch (e) {\n            console.log(\"Error during RayTracing: \" + e);\n            this.reset(); // Reset to avoid another crash\n        }\n    }\n\n    // Generate and render the light map\n    renderLightMap() {\n        this.lightMap.fill(0); // Clear the light map (all black)\n        this.intersections.forEach(intersection => {\n            const brightness = Math.min(Math.max(0, 255 - intersection.dt * 10),15); // Decrease brightness with distance\n            this.lightMap.setPixel(intersection.hx, intersection.hy, brightness);\n        });\n        scene.setBackgroundImage(this.lightMap); // Update the scene with the light map\n    }\n\n    // Check for duplicate intersections\n    isDuplicateIntersection(intersection: { hx: number; hy: number; dt: number }): boolean {\n        return this.intersections.some(existing =>\n            Math.abs(existing.hx - intersection.hx) < 1 &&\n            Math.abs(existing.hy - intersection.hy) < 1\n        );\n    }\n\n    // Add a light source\n    addLight(light: Light) {\n        this.lights.push(light);\n        console.log(\"Rays predicted to be shot each frame: \" + (RAYS_PER_LIGHT * this.lights.length));\n    }\n\n    // Add a mirror\n    addMirror(mirror: Mirror) {\n        this.mirrors.push(mirror);\n        console.log(\"Mirror addded!\")\n    }\n\n    // Reset the raytracer\n    reset() {\n        this.mirrors = []\n        this.lights = [];\n        this.intersections = [];\n        this.lightMap.fill(0); // Clear the light map\n    }\n}\n","raytracer.ts":"const rt = new RayTracer()\r\n","test.ts":"if (game.ask(\"Map 1?\")) {\n    tiles.setCurrentTilemap(tilemap`level1`)\n} else {\n\n    tiles.setCurrentTilemap(tilemap`level2`)\n}\n// nothing else , the rest is handled in the raytracer","map_image_attached_to_tilemap.ts":"/** \n * for configuring the raytracer \n*/\nnamespace raytracer {\n   const scaler = 100 / 15\n   let normalmap:Image = image.create(1,1)\n   let array2d:number[][] = [[]]\n   let enabled_ = true\n   function scaleImageTo2dArray() {    \n    for (let i = 0; i < normalmap.width; i++) {\n      const d:number[] = []\n\n    for (let k = 0; k < normalmap.height; k++) {\n        const c = normalmap.getPixel(i,k) * scaler // get the value and scale it to 0-100\n        d.push(c)\n    }\n      array2d.push(d)\n    }\n   }\n   export function SetRaytracerEnabled(enabled:boolean) {\n      enabled_ = enabled\n   }\n   export function SetCurrentTileMapNormalMap(map:Image) {\n       normalmap = map\n       scaleImageTo2dArray() // then update the 2d array that's faster to read from\n   }\n   export function _read(x:number,y:number) {\n       return array2d[x][y]\n   }\n   export function _enabled() {\n       return enabled_\n   }\n}","pxt.json":"{\n    \"name\": \"ray shooter (IE:2d raytracer)\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\",\n        \"raytracer_class.ts\",\n        \"raytracer.ts\",\n        \"test.ts\",\n        \"map_image_attached_to_tilemap.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1749942435845}